---
title: "Microbiome of Amyotrophic Lateral Sclerosis (ALS) using 16S rRNA"
output:
  github_document:
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, echo=FALSE, message=FALSE, warning=FALSE}
library(printr)
```

<div align="center">
![Stephen Hawking](images/stephen_hawking.png)
</div>

<div align="right"><small>*Stephen Hawking*. Photo Credit: [NASA/Paul E. Alers](https://flic.kr/p/6h1t6B).</small></div>

## Introduction

Amyotrophic lateral sclerosis ([ALS](https://en.wikipedia.org/wiki/Amyotrophic_lateral_sclerosis)) is a neurodegenerative neuromuscular disease that results in the progressive loss of motor neurons that control voluntary muscles. About 20 genes are associated with ALS, most importantly [C9orf72](https://en.wikipedia.org/wiki/C9orf72), which accounts for about 40% of the cases. In addition to genetic risk, environmental factors such as smoking and physical activity represent potential risks. Among the environmental factors is the gut microbiota, which has been shown to contribute and affect mental health, leading to the emerging paradigm of the [gut-brain axis](https://en.wikipedia.org/wiki/Gut%E2%80%93brain_axis) ([GBA](https://en.wikipedia.org/wiki/Gut%E2%80%93brain_axis)). Therefore, [Hertzberg et al. 2021](https://pubmed.ncbi.nlm.nih.gov/33818222/) examined the gut microbiome profiles between ALS patients and their corresponding health caregivers using 16S rRNA.

In this lesson, we are going to reanalyze the generated from this study. The NCBI BioProject accession number is [PRJNA566436](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA566436), composed of 9 ALS patients and corresponding healthy controls (i.e., a total of 18 samples).

The processing of the 16S data will be performed using [DADA2](https://github.com/benjjneb/dada2), implemented in the [Bioconductor](https://www.bioconductor.org/) package [`dada2`](https://www.bioconductor.org/packages/release/bioc/html/dada2.html) ([Callahan et al. 2016](https://pubmed.ncbi.nlm.nih.gov/27214047/)). DADA2 primarily models and corrects [Illumina](https://www.illumina.com/) amplicon sequencing errors (it can handle data generated by other next-generation sequencing (NGS) platforms as well, including [Ion Torrent](https://www.thermofisher.com/eg/en/home/brands/ion-torrent.html) and [454](https://en.wikipedia.org/wiki/454_Life_Sciences)). Most of the subsequent steps are based on the [DADA2 tutorial](https://benjjneb.github.io/dada2/tutorial.html).

## Setting up

### Direcotry Structure

In the working directory, there is a file called `samples.tsv` with a list of the samples and the status (`ALS` vs `Control`) of each sample. The dataset in **paired-end** FASTQ (compressed `.fastq.gz`) is located under `data/original/`. There is also the `data/silva/` folder with the [SILVA](https://www.arb-silva.de/) database for taxonomic classification.

### Installing and Loading Packages

The main package required for this lesson is [`dada2`](https://doi.org/doi:10.18129/B9.bioc.dada2). If it is not installed already, it can installed through [`BiocManager`](https://cran.r-project.org/web/packages/BiocManager/vignettes/BiocManager.html) as follows:

```{r eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("dada2")
```

The main package required for this lesson is [`phyloseq`](https://doi.org/doi:10.18129/B9.bioc.phyloseq). If it is not installed already, it can installed through [`BiocManager`](https://cran.r-project.org/web/packages/BiocManager/vignettes/BiocManager.html) as follows:

```{r eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("phyloseq")
```


Additional, [`tidyverse`](https://www.tidyverse.org/) will be required for data reading, handling, and plotting. Finally, [`digest`](https://cran.r-project.org/web/packages/digest/index.html) will be required for only prettify the names of the operational taxonomic units (OTUs). Both packages can be installed from the The Comprehensive R Archive Network (CRAN) repository as follows:

```{r eval=FALSE}
install.packages(c("tidyverse", "digest"))
```

After all the required packages are successfully installed, typically happens once per `R` installation, let us **load** these package in the current `R` session (workspace):

```{r}
library(dada2)
library(phyloseq)
library(tidyverse)
library(digest)
```

### Loading Meta and Sequence Data

In loading the samples information (metadata), `read_tsv`'s parameter `col_types` takes the `cff` to indicate that the first column in a *character* (string) but the second and third columns are *factor* (categorical) - for more on data types in R, see the episode on [Data Types and Structures](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/)

```{r}
samples = read_tsv("data/samples.tsv", col_types = 'cff')
glimpse(samples)
```

`glimpse` shows that there are 18 rows (samples) and the three columns are `sample`, `status`, and `pair` were loaded successfully as `chr`, `fct`, and `fct`, respectively.

Now let's start processing the FASTQ files. First, we will list all the files in the `original` subfolder.

```{r}
path = "data/original"
list.files(path)
```

The above list will be split into forward and reverse reads, according to the FASTQ file name where file names that end with `1.fastq.gz` are the forward reads and file names that end with `2.fastq.gz` are the reverse reads.

**The forward reads:**

```{r}
forward.original = sort(list.files(path, pattern="1.fastq.gz", full.names = TRUE))
head(forward.original)
```

**The reverse reads:**

```{r}
reverse.original = sort(list.files(path, pattern="2.fastq.gz", full.names = TRUE))
head(reverse.original)
```

The sample name is extracted from the FASTQ file name using [`strsplit`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/strsplit) by searching and taking the part the file name before the underscore `_`. The extracted sample name should match the `sample` column (first column) in the metadata loaded above. With [`sapply`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/lapply), the extraction (`strsplit`) is applied on the list (vector) of names in `forward.original`.

```{r}
sample.names = sapply(strsplit(basename(forward.original), "_"), `[`, 1)
head(sample.names)
```

## Quality Control

### Quality Profiles

#### Forward Reads

We will plot (using [`plotQualityProfile`](https://rdrr.io/bioc/dada2/man/plotQualityProfile.html)) the quality profile of *forward* reads in the first two samples

```{r}
plotQualityProfile(forward.original[1:2])
```

#### Reverse Reads

Then the quality profile of *reverse* reads of the same first two samples above

```{r}
plotQualityProfile(reverse.original[1:2])
```

As expected, the forward reads are typically of higher quality for most of the read length, but for the reverse read, the quality drops about half-way through the read length (starting approximately from the 100th nucleotide)

### Filtering and Trimming

Here, only defining the names (`.1.filtered.fastq.gz` and `.2.filtered.fastq.gz` for the *forward* and *reverse* reads, respectively) and destination subfolder `data/filtered` of the filtered FASTQ files. The sample name `sample.names` will be assigned to the row name of the `data.frame`:

```{r}
forward.filtered = file.path("data/filtered", paste0(sample.names, ".1.filtered.fastq.gz"))
reverse.filtered = file.path("data/filtered", paste0(sample.names, ".2.filtered.fastq.gz"))

names(forward.filtered) = sample.names
names(reverse.filtered) = sample.names
```

Now filter and trim using [`filterAndTrim`](https://rdrr.io/bioc/dada2/man/filterAndTrim.html), which takes input FASTQ files and generates the corresponding output FASTQ files.


```{r}
out = filterAndTrim(forward.original, forward.filtered, 
                    reverse.original, reverse.filtered,
                    minLen = 150, # Pretty stringent but to show difference between the in and out
                    multithread = TRUE) # In case of Windows OS, multithread should be FALSE (which is the default)
head(out)
```

## Sample Composition

Now it comes to the nuts and bolts of using **DADA2** in infer sample compsition

### Learn Error Rates

**DADA2** uses of a parametric error model per every amplicon dataset. The error learning process is performed by [`learnErrors`](https://rdrr.io/bioc/dada2/man/learnErrors.html) from the *data*. The approach is to alternate the estimation of the error rates and the inference of sample composition until the two converge.

#### Forward Reads Errors

```{r warning=FALSE}
forward.errors = learnErrors(forward.filtered, multithread = TRUE)
plotErrors(forward.errors, nominalQ = TRUE) # Plot observed frequency of each transition
```

#### Reverse Reads Errors

```{r warning=FALSE}
reverse.errors = learnErrors(reverse.filtered, multithread = TRUE)
plotErrors(reverse.errors, nominalQ = TRUE) # Plot observed frequency of each transition
```

### Sample Inference

Now it is time to apply the sample inference algorithm, not surprisingly the main method is called [`dada`](https://rdrr.io/bioc/dada2/man/dada.html) :wink: This method removes all estimated errors from the filtered sequence reads and estimates the composition of each sample.

#### Forward Sample Inference

```{r}
forward.dada = dada(forward.filtered, err = forward.errors, multithread = TRUE)
head(forward.dada)
```

#### Reverse Sample Inference

```{r}
reverse.dada = dada(reverse.filtered, err = reverse.errors, multithread = TRUE)
head(reverse.dada)
```

### Merge Paired Reads

Now the denoised forward and reverse mates of the paired-end reads are merged into full sequences using [`mergePairs`](https://rdrr.io/bioc/dada2/man/mergePairs.html). To merge, the reverse read is *reverse complemented* and aligned to the forward read. And paired reads that do not overlap exactly are removed from the merged output.

```{r}
mergers = mergePairs(forward.dada, forward.filtered, reverse.dada, reverse.filtered, verbose = TRUE)
head(mergers[[1]]) # Inspect the merger data.frame of the first sample
```

*From the documentation of the method*:

The return `data.frame`(s) has a row for each unique pairing of forward/reverse denoised sequences, and the following columns:

 - `$abundance`: Number of reads corresponding to this forward/reverse combination.
 - `$sequence`: The merged sequence.
 - `$forward`: The index of the forward denoised sequence.
 - `$reverse`: The index of the reverse denoised sequence.
 - `$nmatch`: Number of matches nts in the overlap region.
 - `$nmismatch`: Number of mismatches in the overlap region.
 - `$nindel`: Number of indels in the overlap region.
 - `$prefer`: The sequence used for the overlap region. 1=forward; 2=reverse.
 - `$accept`: `TRUE` if overlap between forward and reverse denoised sequences was at least `minOverlap` and had at most `maxMismatch` differences. `FALSE` otherwise.

## Construct sequence table
We can now construct an amplicon sequence variant table (ASV) table, a higher-resolution version of the OTU table produced by traditional methods.

```{r}
seqtab = makeSequenceTable(mergers)
dim(seqtab)
```

```{r}
# Inspect distribution of sequence lengths
table(nchar(getSequences(seqtab)))
```

The sequence table is a `matrix` with rows corresponding to (and named by) the samples, and columns corresponding to (and named by) the sequence variants. This table contains 293 ASVs, and the lengths of our merged sequences all fall within the expected range for this V4 amplicon.

*Considerations for your own data:* Sequences that are much longer or shorter than expected may be the result of non-specific priming. You can remove non-target-length sequences from your sequence table (eg. `seqtab2 = seqtab[,nchar(colnames(seqtab)) %in% 250:256]`). This is analogous to “cutting a band” in-silico to get amplicons of the targeted length.

## Remove chimeras
The core `dada` method corrects substitution and indel errors, but chimeras remain. Fortunately, the accuracy of sequence variants after denoising makes identifying chimeric ASVs simpler than when dealing with fuzzy OTUs. Chimeric sequences are identified if they can be exactly reconstructed by combining a left-segment and a right-segment from two more abundant “parent” sequences.

```{r}
seqtab.nochim = removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim)
```

```{r}
sum(seqtab.nochim)/sum(seqtab)
```

The frequency of chimeric sequences varies substantially from dataset to dataset, and depends on on factors including experimental procedures and sample complexity. Here chimeras make up about 21% of the merged sequence variants, but when we account for the abundances of those variants we see they account for only about 4% of the merged sequence reads.

*Considerations for your own data:* Most of your reads should remain after chimera removal (it is not uncommon for a majority of sequence variants to be removed though). If most of your reads were removed as chimeric, upstream processing may need to be revisited. In almost all cases this is caused by primer sequences with ambiguous nucleotides that were not removed prior to beginning the DADA2 pipeline.

## Track reads through the pipeline
As a final check of our progress, we’ll look at the number of reads that made it through each step in the pipeline:

```{r}
getN = function(x) sum(getUniques(x))
track = cbind(out, sapply(forward.dada, getN), sapply(reverse.dada, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
# If processing a single sample, remove the sapply calls: e.g. replace sapply(forward.dada, getN) with getN(forward.dada)
colnames(track) = c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
rownames(track) = sample.names
head(track)
```

Looks good! We kept the majority of our raw reads, and there is no over-large drop associated with any single step.

*Considerations for your own data:* This is a great place to do a last **sanity check**. Outside of filtering, there should no step in which a majority of reads are lost. If a majority of reads failed to merge, you may need to revisit the `truncLen` parameter used in the filtering step and make sure that the truncated reads span your amplicon. If a majority of reads were removed as chimeric, you may need to revisit the removal of primers, as the ambiguous nucleotides in unremoved primers interfere with chimera identification.

# Taxonomic Classification

## Assign taxonomy

It is common at this point, especially in 16S/18S/ITS amplicon sequencing, to assign taxonomy to the sequence variants. The DADA2 package provides a native implementation of the [naive Bayesian classifier method](http://www.ncbi.nlm.nih.gov/pubmed/17586664) for this purpose. The `assignTaxonomy` function takes as input a set of sequences to be classified and a training set of reference sequences with known taxonomy, and outputs taxonomic assignments with at least `minBoot` bootstrap confidence.

We maintain [formatted training fastas for the RDP training set, GreenGenes clustered at 97% identity, and the Silva reference database](https://benjjneb.github.io/dada2/training.html), and additional trainings fastas suitable for protists and certain specific environments have been contributed. For fungal taxonomy, the General Fasta release files from the [UNITE ITS database](https://unite.ut.ee/repository.php) can be used as is. To follow along, download the `silva_nr_v138_train_set.fa.gz` file, and place it in the directory with the fastq files.


```{r}
taxa = assignTaxonomy(seqtab.nochim, "data/silva/silva_nr99_v138_train_set.fa.gz", multithread=TRUE)
head(taxa)
```

*Extensions*: The dada2 package also implements a method to make [species level assignments based on exact matching](https://benjjneb.github.io/dada2/assign.html#species-assignment) between ASVs and sequenced reference strains. Recent analysis suggests that [exact matching (or 100% identity) is the only appropriate way to assign species to 16S gene fragments](https://academic.oup.com/bioinformatics/advance-article-abstract/doi/10.1093/bioinformatics/bty113/4913809). Currently, [species-assignment training fastas are available for the Silva and RDP 16S databases](https://benjjneb.github.io/dada2/training.html). To follow the optional species addition step, download the `silva_species_assignment_v138.fa.gz` file, and place it in the directory with the fastq files.

```{r}
taxa = addSpecies(taxa, "data/silva/silva_species_assignment_v138.fa.gz")
head(taxa)
```



```{r}
md5 = lapply(colnames(seqtab.nochim), digest)
colnames(seqtab.nochim) = md5

otus = as.matrix(seqtab.nochim)
colnames(otus) = md5
otus[1:2, 1:2]
```



```{r}
rownames(taxa) = lapply(rownames(taxa), digest)
head(taxa)
```



Let’s inspect the taxonomic assignments:

```{r}
taxa.print = taxa # Removing sequence rownames for display only
rownames(taxa.print) = NULL
head(taxa.print)
```

Unsurprisingly, the Bacteroidetes are well represented among the most abundant taxa in these fecal samples. Few species assignments were made, both because it is often not possible to make unambiguous species assignments from subsegments of the 16S gene, and because there is surprisingly little coverage of the indigenous mouse gut microbiota in reference databases.

*Considerations for your own data:* If your reads do not seem to be appropriately assigned, for example lots of your bacterial 16S sequences are being assigned as `Eukaryota NA NA NA NA NA`, your reads may be in the opposite orientation as the reference database. Tell dada2 to try the reverse-complement orientation with `assignTaxonomy(..., tryRC=TRUE)` and see if this fixes the assignments. If using DECIPHER for taxonomy, try `IdTaxa (..., strand="both")`.

# Handoff to phyloseq

The phyloseq R package is a powerful framework for further analysis of microbiome data. We now demonstrate how to straightforwardly import the tables produced by the DADA2 pipeline into phyloseq. We’ll also add the small amount of metadata we have – the samples are named by the gender (G), mouse subject number (X) and the day post-weaning (Y) it was sampled (eg. GXDY).

## Import into phyloseq:
We can construct a simple sample data.frame from the information encoded in the filenames. Usually this step would instead involve reading the sample data in from a file.

```{r}
samples = as.data.frame(samples)
row.names(samples) = samples$sample
samples
```

We now construct a phyloseq object directly from the dada2 outputs.

```{r}
ps = phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE),  sample_data(samples),  tax_table(taxa))
ps
```

We are now ready to use phyloseq!

Visualize alpha-diversity:

```{r}
plot_richness(ps, x="status", measures=c("Shannon", "Simpson"), color = "pair")
```

No obvious systematic difference in alpha-diversity between early and late samples.


```{r}
ps_rank = transform_sample_counts(ps, threshrankfun(50))
ps_log = transform_sample_counts(ps, log)
ps_norm = transform_sample_counts(ps, function(x) x / sum(x))
```


Ordinate:
Transform data to proportions as appropriate for Bray-Curtis distances
```{r}
ord.nmds.bray = ordinate(ps_norm, method="NMDS", distance="bray")
plot_ordination(ps, ord.nmds.bray, color="status", title="Bray NMDS") + geom_point(size = 3)
```

Ordination picks out a clear separation between the early and late samples.

## Bar plot

```{r}
ps
ps_norm  = transform_sample_counts(ps, function(x) x / sum(x) )
ps_filtered = filter_taxa(ps_norm, function(x) mean(x) > 1e-3, prune = TRUE)
ps_filtered
```

```{r}
plot_bar(ps_filtered, x="status", fill="Phylum") + geom_bar(aes(fill=Phylum), stat="identity", position="stack", color = "white")
```


```{r}
plot_bar(ps_norm, x="status", fill="Phylum")
```

Normalize number of reads in each sample using median sequencing depth.

```{r}
total = median(sample_sums(ps))
standf = function(x, t=total) round(t * (x / sum(x)))
ps2 = transform_sample_counts(ps, standf)
ps2
```


```{r}
top20 = names(sort(taxa_sums(ps), decreasing=TRUE))[1:20]
ps.top20 = transform_sample_counts(ps, function(OTU) OTU/sum(OTU))
ps.top20 = prune_taxa(top20, ps.top20)

plot_bar(ps.top20, x="status", fill="Phylum")
```

